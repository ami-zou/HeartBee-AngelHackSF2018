//
//  EventsFMDBDatabaseManager.swift
//  core-ios-sdk
//
//  Created by Ashish Asawa on 07/06/18.
//  Copyright Â© 2018 www.hypertrack.com. All rights reserved.
//

import Foundation

final class EventsFMDBDatabaseManager: AbstractDatabaseProtocol {

    struct Info {
        let tableName: String
    }
    
    typealias T = Event
    
    let fieldEventID                    = "eventID"                 // numeric autogenerated id, primary key
    let fieldId                         = "id"
    let fieldType                       = "type"
    let fieldData                       = "data"
    let fieldRecordedAt                 = "recorded_at"
    
    private let dbManager: FMDBManager
    
//    typealias T = AbstractEventData
    
    private let info: Info

    public init(eventInfo info : Info, dbManager: FMDBManager) {
        self.info = info
        self.dbManager = dbManager
        createTable(withName: info.tableName)
    }
    
    private func getRowCount() -> Int {
        let columnName = "Count"
        let sqlStatement = "select count(*) as \(columnName) from \(info.tableName)"
        let queryResult = dbManager.execute(selectQuery: sqlStatement, values: nil)
        guard let result = queryResult.0 else {
            return 0
        }
        if result.next() {
            return Int(result.int(forColumn: columnName))
        } else {
            return 0
        }
    }
    
    private func createTable(withName name: String) {
        let createEventsTableQuery = "create table \(name) (\(fieldEventID) integer primary key autoincrement not null, \(fieldId) text not null, \(fieldType) text not null, \(fieldData) text not null, \(fieldRecordedAt) text not null)"
        let dbResult = dbManager.execute(updatesForQuery: createEventsTableQuery, values: nil)
        //TODO: Logging and error handling, asserts
        if dbResult.0 == true {
            debugPrint("Table Created Successfully")
        } else {
            debugPrint("Table Error \(dbResult.1 ?? "unkown")")
        }
    }
    
    // MARK: AbstractDatabaseProtocol Methods
    func insert(items:  [T],     result: @escaping (DataBaseResult<[T]>) -> Void) {
        let values = items.map({ (item) in
            return "(null, '\(item.id)', '\(item.type.rawValue)', '\(item.data)', '\(item.recordedAt)')"
        }).joined(separator: ",")
        let sql = "insert into \(info.tableName) (\(fieldEventID), \(fieldId), \(fieldType), \(fieldData), \(fieldRecordedAt)) values \(values);"
        let dbResult = dbManager.execute(sqlStatements: sql)
        if dbResult.0 == true {
            result(DataBaseResult.success(items))
        } else {
            result(DataBaseResult.failure(dbResult.1 ?? "Failed to insert for \(info.tableName)"))
        }
    }
    
    func delete(items:  [T],   result: @escaping (DataBaseResult<[T]>) -> Void) {
        let formattedIds = items.map({ (item) in
            return "'\(item.id)'"
        }).joined(separator: ",")
        let sql = "delete from \(info.tableName) where \(fieldId) IN (\(formattedIds));"
        let dbResult = dbManager.execute(sqlStatements: sql)
        if dbResult.0 == true {
            result(DataBaseResult.success(items))
        } else {
            result(DataBaseResult.failure(dbResult.1 ?? "Failed to delete for \(info.tableName)"))
        }
    }
    
    func fetch( count:  UInt,  result: @escaping (DataBaseResult<[T]>) -> Void) {
        let query = "select * from \(info.tableName)\(count <= 0 ? "" : " limit \(count)")"
        let dbResult = dbManager.execute(selectQuery: query, values: nil)
        var records:[T] = []
        guard let results = dbResult.0 else {
            result(DataBaseResult.failure(dbResult.1 ?? "Failed to fetch for \(info.tableName)"))
            return
        }
        while true {
            do {
                try results.nextWithError()
                guard let id         = results.string(forColumn: fieldId),
                      let type       = results.string(forColumn: fieldType),
                      let data       = results.string(forColumn: fieldData),
                      let recordedAt = results.string(forColumn: fieldRecordedAt),
                      let eventType  = EventType(rawValue: type) else {
                        continue
                }
                let record = T(type:  eventType, data: data, id: id, recordedAt: recordedAt)
                records.append(record)
            } catch _ {
                results.close()
                break
            }
        }
        results.close()
        result(DataBaseResult.success(records))
    }
    
    func deleteAll(result: @escaping (_ status: Bool) -> Void) {
        let query = "DELETE from \(info.tableName)"
        let dbResult = dbManager.execute(updatesForQuery: query, values: nil)
        result(dbResult.0)
    }
    
}
